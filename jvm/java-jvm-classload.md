# java 类加载


##  类加载器
<B>类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class对象，用来封装类在方法区内的数据结构</B>

#### 加载过程
![Alt text](./images/类加载机制.png)


##### 链接
  
###### 验证

验证的主要作用就是确保被加载的类的正确性。

四个阶段的验证：

- 文件格式的验证

- 元数据验证

- 字节码验证

- 符号引用验证

###### 准备
正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配

构建方法表




###### 解析

- 符号引用与直接引用

 符号引用（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经在内存中。 

直接引用（Direct Reference）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。


虚拟机规范中未规定解析阶段发生的具体时间，只要求在执行 anewarray，checkcast，getfield，getstatic，instanceof，invokedynamic，invokeinterface，invokespecial，invokestatic，invokevirtual，ldc，ldc_w，multianewarray，new，putfield 和 putstatic 这 16 个用于操作符号引用的字节码指令之前，先对他们所使用的符号进行解析。所以虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析他。

上述指令对应的操作分别为：
anewarray、multianewarray：创建数组
checkcast、instanceof：检查类实例类型
getfield、getstatic、putfield、putstatic：访问类字段（static 字段，或者称为类变量）和实例字段（非 static 字段，或者称为实例变量）
invokeinterface：调用接口方法，他会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用
invokespecial：调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法
invokestatic：调用类方法（static 方法）
invokevirtual：调用对象实例方法，根据对象的实际类型进行分派（虚方法分派），这也是 java 语言中最常见的分派方式
invokedynamic：用于在运行时动态解析出调用点限定符所引用的方法，并执行改方法
ldc：将一个常量加载到操作数栈的指令
ldc_w：将一个常量加载到操作数栈的指令
new：创建类实例


解新动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行,
分别对应于常量池的
CONSTANT_Class_info、 
CONSTANT_Fieldref_info、
CONSTANT_Methodref_info、
CONSTANT_IntrfaceMethodref_info、
CONSTANT_MethodType_info、
CONSTANT_MethodHandle_info、
CONSTANT_InvokeDynamic_info
7种常量类型。 

1、类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。 
```
1. 如果该符号引用不是一个数组类型，那么虚拟机将会把该符号代表的全限定名称传递给类加载器去加载这个类。这个过程由于涉及验证过程所以可能会触发其他相关类的加载

2. 如果该符号引用是一个数组类型，并且该数组的元素类型是对象。我们知道符号引用是存在方法区的常量池中的，该符号引用的描述符会类似”[java/lang/Integer”的形式，将会按照上面的规则进行加载数组元素类型，如果描述符如前面假设的形式，需要加载的元素类型就是java.lang.Integer ,接着由虚拟机将会生成一个代表此数组对象的直接引用

3. 如果上面的步骤都没有出现异常，那么该符号引用已经在虚拟机中产生了一个直接引用，但是在解析完成之前需要对符号引用进行验证，主要是确认当前调用这个符号引用的类是否具有访问权限，如果没有访问权限将抛出java.lang.IllegalAccess异常

```

2、字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束。
```
1. 如果该字段符号引用就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，解析结束

2. 否则，如果在该符号的类实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果在接口中包含了简单名称和字段描述符都与目标相匹配的字段，那么久直接返回这个字段的直接引用，解析结束

3. 否则，如果该符号所在的类不是Object类的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都相匹配的字段，那么直接返回这个字段的直接引用，解析结束

4. 否则，解析失败，抛出java.lang.NoSuchFieldError异常

``` 

3、类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。 
```
1. 类方法和接口方法的符号引用是分开的，所以如果在类方法表中发现class_index（类中方法的符号引用）的索引是一个接口，那么会抛出java.lang.IncompatibleClassChangeError的异常

2. 如果class_index的索引确实是一个类，那么在该类中查找是否有简单名称和描述符都与目标字段相匹配的方法，如果有的话就返回这个方法的直接引用，查找结束

3. 否则，在该类的父类中递归查找是否具有简单名称和描述符都与目标字段相匹配的字段，如果有，则直接返回这个字段的直接引用，查找结束

4. 否则，在这个类的接口以及它的父接口中递归查找，如果找到的话就说明这个方法是一个抽象类，查找结束，返回java.lang.AbstractMethodError异常

5. 否则，查找失败，抛出java.lang.NoSuchMethodError异常

```



4、接口方法解析：与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了。 
```
1. 如果在接口方法表中发现class_index的索引是一个类而不是一个接口，那么也会抛出java.lang.IncompatibleClassChangeError的异常

2. 否则，在该接口方法的所属的接口中查找是否具有简单名称和描述符都与目标字段相匹配的方法，如果有的话就直接返回这个方法的直接引用。

3. 否则，在该接口以及其父接口中查找，直到Object类，如果找到则直接返回这个方法的直接引用

4. 否则，查找失败

```


“动态解析”的含义就是必须等到程序实际运行到这条指令的时候，解析动作才能进行。相对的，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码时就进行解析。


##### 初始化

初始化时机：
  - 遇到new、putstatic、getstatic及invokestatic这4条字节码指令时，如果类没有初始化，则立即进行初始化，这4个命令分别代表实例化一个类、设置&读取一个静态字段(没有被final修饰)、调用类的静态方法；
    2、使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化；
    3、当初始化一个类的时候，发现其父类没有初始化；
    4、当虚拟机启动时，需用将执行启动的主类(有main()方法的那个类)进行初始化；
   5、当使用动态语言时，如果一个java.lang.invoke.MethodHandle实例最终的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic句柄时，并且这个句柄对应的类没有初始化。


当程序中只存在类的被动引用时，该类不会被初始化。被动引用包括以下几种情况：

- 通过子类引用父类的静态字段，不会导致子类的初始化。
- 定义对象数组，不会触发类的初始化。
- 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量的类的初始化。
- 通过类名获取Class对象，不会触发类的初始化。
- Class.forName()方法加载类时，如果指定参数initialize为false时，也不会触发类的初始化。

通过测试发现，以下几种情况接口会被初始化：

- 调用接口中不在常量池中的常量（对static字段的引用引发的初始化只会初始化实际定义的接口（尽管可以通过实现类，子接口的名称进行引用（而接口中的static方法不能被继承）））
调用接口中的静态方法
当初始化一个类时，将初始化这个类实现的所有的包含default方法的接口和超接口
java.lang.reflect可能会导致接口初始化
初始化接口本身不会导致任何超接口的初始化（注意和第3条的区别）


<clinit>方法的执行规则:

    1、<clinit>（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。

    2、<clinit>（）方法与实例构造器<init>（）方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>（）方法执行之前，父类的<clinit>（）方法已经执行完毕。因此，在虚拟机中第一个被执行的<clinit>（）方法的类肯定是java.lang.Object。

    3、<clinit>（）方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成<clinit>（）方法。

    4、接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成<clinit>（）方法。但是接口与类不同的是：执行接口的<clinit>（）方法不需要先执行父接口的<clinit>（）方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>（）方法。

    5、虚拟机会保证一个类的<clinit>（）方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>（）方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>（）方法完毕。如果在一个类的<clinit>（）方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。


---

####双亲委派

   1）启动（Bootstrap）类加载器：是用本地代码实现的类装入器，它负责将 <Java_Runtime_Home>/lib下面的类库加载到内存中（比如rt.jar）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。 

     2）标准扩展（Extension）类加载器：是由 Sun 的 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将< Java_Runtime_Home >/lib/ext或者由系统变量 java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。 

     3）系统（System）类加载器：是由 Sun 的 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。它负责将系统类路径（CLASSPATH）中指定的类库加载到内存中。开发者可以直接使用系统类加载器。 

双亲委派机制描述： 
     某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 
 


---

#### 破话双亲委派机制